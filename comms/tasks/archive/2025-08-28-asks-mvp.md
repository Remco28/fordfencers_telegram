# Task: Phase 1 ‚Äî Asks (Multi‚ÄëAssignee) MVP

## Objective
Implement ‚ÄúAsk <someone> to do <thing>‚Äù flows with multi‚Äëassignee support, all via private messages to keep the group chat clean. Provide a simple way to create asks, list personal assignments, mark items done with confirmation, notify requesters on completion, and view all open asks.

## User Stories
- As a family member, I can create an Ask in DM, pick multiple people, write the request text, and submit it.
- As an assignee, I can see ‚ÄúMy Asks‚Äù in DM and mark items as done (with confirmation).
- As the requester, I receive a DM when someone marks my Ask done.
- As any family member, I can see a compact list of all open Asks (in DM) with who they‚Äôre assigned to.

## Scope (MVP)
- DM-only interactive flows for creation and management. Group chat remains clean; optional group summary deferred.
- No due dates or scheduling. Status only: open/done per assignee; Ask auto‚Äëcloses when all assignees are done.
- Simple roster based on users who have DM‚Äëstarted the bot or otherwise interacted (we store user_id + display name when we see them).

Out of scope: date handling, reminders, exports, migrations framework, advanced permissions, or admin roles.

## Data Model (SQLite)
- `users(id INTEGER PRIMARY KEY, user_id INTEGER UNIQUE NOT NULL, display_name TEXT NOT NULL, created_at TEXT NOT NULL)`
- `asks(id INTEGER PRIMARY KEY, chat_id INTEGER NOT NULL, requester_id INTEGER NOT NULL, requester_name TEXT NOT NULL, text TEXT NOT NULL, status TEXT NOT NULL CHECK (status IN ('open','closed')), created_at TEXT NOT NULL, closed_at TEXT)`
- `ask_assignees(id INTEGER PRIMARY KEY, ask_id INTEGER NOT NULL, assignee_id INTEGER NOT NULL, assignee_name TEXT NOT NULL, status TEXT NOT NULL CHECK (status IN ('open','done')), done_at TEXT, FOREIGN KEY(ask_id) REFERENCES asks(id) ON DELETE CASCADE)`

Indexes:
- `CREATE INDEX IF NOT EXISTS idx_asks_chat_status ON asks(chat_id, status);`
- `CREATE INDEX IF NOT EXISTS idx_assign_assignee_status ON ask_assignees(assignee_id, status);`

Semantics:
- An Ask starts `open`. When all `ask_assignees.status='done'`, set Ask `status='closed'` and `closed_at=now`.
- Store timestamps as UTC ISO strings. Display names from Telegram first/last name; we‚Äôll revisit nicknames later.

## Files & Modules
- `db.py`
  - `init_db()` ‚Äì create tables, enable WAL/PRAGMAs.
  - `register_user(user_id: int, display_name: str) -> None`.
  - `get_roster() -> list[tuple[user_id, display_name]]` (ordered by display_name).
  - `create_ask(chat_id:int, requester_id:int, requester_name:str, text:str, assignees:list[tuple[user_id,int,str]]) -> int` returns ask_id.
  - `list_my_open_assignments(user_id:int) -> list[dict]` (each: assignment_id, ask_id, text, requester_name).
  - `mark_assignment_done(assignment_id:int, assignee_id:int, when_utc:str) -> tuple[ask_id, requester_id, requester_name, text]` (validates ownership; returns info for notification).
  - `get_all_open_asks(chat_id:int) -> list[dict]` (ask_id, text, assignees:[(name,status)]).
  - `maybe_close_ask(ask_id:int, when_utc:str) -> bool` (if all done, close and set closed_at).

- `handlers/asks.py`
  - Conversation for ‚ÄúNew Ask‚Äù (DM): multi‚Äëselect assignees ‚Üí enter text ‚Üí confirm & create ‚Üí DM assignees.
  - Commands (DM): `/my_asks` (list + Done buttons with confirmation), `/asks_all` (compact summary).
  - Callback handlers for: toggle assignee selection, next/back/cancel, confirm done yes/no.

- `keyboards.py`
  - Add builders: `assignee_picker(roster, selected_ids)`, `asks_list(items)`, `confirm_done(assign_id)`, `main_menu_dm()` with: New Ask, My Asks, All Open Asks.

- `app.py`
  - Call `db.init_db()` at startup.
  - Register new handlers and conversation.

- `handlers/commands.py`
  - On any DM command (`/start`, `/my_asks`, etc.), call `db.register_user()` for the user to seed roster.
  - In group: if users press menu options, reply with a short hint to DM the bot.

## Callback Data Protocol (<= 64 bytes)
Prefix all callbacks with `ak:`
- Assignee toggle: `ak:t:<uid>`
- Next (from picker): `ak:n`
- Cancel: `ak:c`
- Submit new ask: `ak:s` (after entering text)
- My asks view: buttons for Done: `ak:d:<assign_id>` ‚Üí opens confirm
- Confirm done yes/no: `ak:dy:<assign_id>`, `ak:dn:<assign_id>`

## Commands & Flows
DM Commands:
- `/start` ‚Äì existing, extend to show DM main menu.
- `/ask` ‚Äì start New Ask conversation in DM and immediately show the assignee picker (same UX as pressing the DM menu button). Must work without relying on a callback; see implementation notes below.
- `/my_asks` ‚Äì list open assignments for current user with Done buttons.
- `/asks_all` ‚Äì show compact list of all open asks for the family group.

Group Behavior:
- `/start` or pressing main menu buttons: send a gentle nudge to DM (e.g., ‚ÄúI‚Äôll DM you. Please start the bot privately if you haven‚Äôt yet.‚Äù). Do not post ask lists or flows in group.

### New Ask Conversation (DM)
States: `PICK_ASSIGNEES`, `ENTER_TEXT`, `CONFIRM_SUBMIT`.
1) Entry: from `/ask` (DM command) or DM menu button ‚Üí fetch roster via `db.get_roster()`. If empty, instruct user that family must DM-start the bot to appear. Show multi-select picker. The entry function must support both origins: callback query (menu button) and DM message (command).
2) `PICK_ASSIGNEES`: Toggle assignees with `ak:t:<uid>`. Proceed with `ak:n` only if at least one selected.
3) `ENTER_TEXT`: Prompt ‚ÄúWhat would you like them to do?‚Äù Capture next text message (trim, max length guard).
4) `CONFIRM_SUBMIT`: Show summary: ‚ÄúAsk X people to: <text>‚Äù with Submit `ak:s` and Cancel `ak:c`.
5) On submit: `db.create_ask(...)` and DM each assignee: ‚Äú<requester_name> asked you: <text>‚Äù. If DM fails (user hasn‚Äôt started bot), catch and ignore; the assignment still exists.

### My Asks (DM)
- `/my_asks`: Use `db.list_my_open_assignments(user_id)` ‚Üí render each with a ‚ÄúDone‚Äù button `ak:d:<assign_id>`.
- On Done click: replace item row with confirmation buttons `ak:dy:<assign_id>` / `ak:dn:<assign_id>`.
- On confirm yes: `db.mark_assignment_done(assign_id, assignee_id, now_utc)` and `db.maybe_close_ask(ask_id, now_utc)`. Then DM requester: ‚Äú<assignee_name> marked done: <text>‚Äù. Update the list in place.

### All Open Asks (DM)
- `/asks_all`: Fetch `db.get_all_open_asks(chat_id)` (use the configured allowed group id if only one) and render a compact text list: ‚Äú‚Ä¢ <text> ‚Äî [Alice open, Ben done]‚Äù. No buttons in MVP.

## Constraints & Guards
- Keep all group interactions minimal; do not post lists/flows in group.
- Enforce `ALLOWED_CHAT_IDS` for group commands; DM flows allowed without chat restriction.
- Parameterize all SQL; open a new connection per operation; enable WAL.
- Respect callback length limits; avoid verbose payloads.
- Handle exceptions quietly with concise user-friendly messages; log details.
- When choosing a family `chat_id` for storing Asks, prefer `PRIMARY_CHAT_ID` (if introduced later) or pick deterministically: `primary_chat_id = next(iter(settings.ALLOWED_CHAT_IDS))`.

## Pseudocode Sketches
db.py
```python
def init_db():
    with sqlite3.connect(DB_PATH) as c:
        c.execute("PRAGMA journal_mode=WAL;")
        c.execute("PRAGMA foreign_keys=ON;")
        # create tables + indexes

def register_user(user_id, display_name):
    upsert into users

def create_ask(chat_id, requester_id, requester_name, text, assignees):
    insert into asks(... 'open' ...); get ask_id
    for uid, name in assignees: insert into ask_assignees(ask_id, uid, name, 'open')
    return ask_id

def list_my_open_assignments(user_id):
    select aa.id as assign_id, a.id as ask_id, a.text, a.requester_name
    from ask_assignees aa join asks a on a.id=aa.ask_id
    where aa.assignee_id=? and aa.status='open' and a.status='open'

def mark_assignment_done(assign_id, assignee_id, when):
    update ask_assignees set status='done', done_at=? where id=? and assignee_id=?
    select a.id, a.requester_id, a.requester_name, a.text from asks a join ask_assignees aa on ... where aa.id=?

def maybe_close_ask(ask_id, when):
    if no open assignees remain: update asks set status='closed', closed_at=?
```

handlers/asks.py (high level)
```python
PICK_ASSIGNEES, ENTER_TEXT, CONFIRM_SUBMIT = range(3)

async def start_new_ask(update, context):
    # Must support BOTH entry paths:
    # - via DM menu button (callback_query present)
    # - via /ask in DM (message present, no callback_query)
    user = update.effective_user
    if not user:
        return ConversationHandler.END
    db.register_user(user.id, display_name_from(user))
    roster = db.get_roster()
    if not roster:
        send = (update.callback_query.edit_message_text if update.callback_query else update.message.reply_text)
        if update.callback_query:
            await update.callback_query.answer()
        await send("No family members have started the bot yet. Ask them to send /start to the bot first!")
        return ConversationHandler.END
    context.user_data['sel'] = set()
    send = (update.callback_query.edit_message_text if update.callback_query else update.message.reply_text)
    if update.callback_query:
        await update.callback_query.answer()
    await send("Who should I ask? Select one or more people:", reply_markup=assignee_picker(roster, set()))
    return PICK_ASSIGNEES

async def on_toggle_assignee(update, context):  # ak:t:<uid>
    # toggle in context.user_data['sel']; re-render picker

async def on_picker_next(update, context):  # ak:n
    # if sel empty -> alert; else prompt for text

async def on_text_entered(update, context):
    context.user_data['text'] = update.message.text.strip()
    # show summary + submit/cancel

async def on_submit(update, context):  # ak:s
    ask_id = db.create_ask(..., assignees=selected)
    # DM assignees; ignore failures
    # confirm to requester
    return ConversationHandler.END

async def my_asks(update, context):
    items = db.list_my_open_assignments(user_id)
    # render with Done buttons ak:d:<assign_id>

async def on_done_click(update, context):  # ak:d:<assign_id>
    # swap button row to confirm ak:dy / ak:dn

async def on_done_confirm(update, context):  # ak:dy:<assign_id>
    info = db.mark_assignment_done(assign_id, user_id, now)
    db.maybe_close_ask(info.ask_id, now)
    # DM requester; refresh list
```

keyboards.py (sketch)
```python
def assignee_picker(roster, selected):
    # each button label: "‚úì Name" if selected else "Name"; callback ak:t:<uid>
    # include Next (ak:n) and Cancel (ak:c)

def asks_list(items):
    # for each item: label=f"{text} (from {requester})"; button Done -> ak:d:<assign_id>

def confirm_done(assign_id):
    # Yes -> ak:dy:<assign_id>, No -> ak:dn:<assign_id>
```

## Acceptance Criteria
- In DM, I can create an Ask by selecting multiple assignees from a roster and providing text; assignees are created in DB.
- Assignees who have started the bot receive a DM notification on creation (others are silently skipped).
- `/my_asks` in DM lists my open assignments with a Done button; clicking Done requires confirmation; confirming marks it done.
- When I mark an assignment done, the requester receives a DM naming me and the Ask text.
- When all assignments for an Ask are done, the Ask becomes closed.
- `/asks_all` in DM shows a compact list of open Asks with assignee statuses.
- Group chat remains clean; bot nudges users to DM for these flows.
- `/ask` in DM works without errors and starts the same conversation as pressing ‚Äúüìù New Ask‚Äù (DM menu button).

## Implementation Notes for /ask (DM) Entry
- In `handlers/commands.ask_command`:
  - If in group, reply with a nudge to DM and return.
  - If in DM, call `register_user_if_dm(update)` and then `return await start_new_ask(update, context)` directly. Do not fabricate a fake `callback_query`.
- In `handlers/asks.start_new_ask`:
  - Add branching for origin: if `update.callback_query` use `answer()` and `edit_message_text()`. Otherwise, use `update.message.reply_text()`.
- For selecting the family `chat_id` when creating or listing Asks, prefer `next(iter(settings.ALLOWED_CHAT_IDS))` for determinism.

## Notes
- Keep handlers resilient (ignore missing DMs, handle race conditions if two taps occur).
- Enforce callback size limits and avoid leaking PII in callback data.
- Maintain consistent logging at INFO level (user_id, chat_id, action).
